# Тестовое задание Backend: API управления заказами

Этот проект представляет собой бэкенд-решение, разработанное в рамках тестового задания, сосредоточенное на функциональности управления заказами и каталогом товаров. Проект включает в себя RESTful API для добавления позиций в заказы клиентов, демонстрацию дизайна схемы базы данных и реализацию SQL-запросов. Детальное техническое задание доступно в файле `ТЗ Backend .pdf` в корне проекта.

## Используемые технологии

*   **Python**: Основной язык программирования.
*   **FastAPI**: Современный, высокопроизводительный веб-фреймворк для создания API на Python 3.7+ с использованием подсказок типов.
*   **PostgreSQL**: Мощная объектно-реляционная система управления базами данных.
*   **SQLAlchemy**: Инструментарий SQL для Python, используемый для выполнения прямых SQL-запросов.
*   **asyncpg**: Быстрая клиентская библиотека PostgreSQL для Python/asyncio.
*   **Docker & Docker Compose**: Для контейнеризации и упрощения локальной разработки и развертывания.

## Структура проекта

```
.
├── .env                  # Переменные окружения для Docker Compose и подключения к БД
├── .env_test             # Переменные окружения для тестовой базы данных
├── .gitignore            # Указывает игнорируемые файлы для системы контроля версий
├── ТЗ Backend .pdf       # Техническое задание
├── README.md             # Этот файл
├── compose.yml           # Конфигурация Docker Compose для локальной разработки
├── compose.test.yml      # Конфигурация Docker Compose для запуска тестовой БД
├── config.py             # Конфигурация приложения (доступ к переменным окружения через Pydantic Settings)
├── Dockerfile            # Dockerfile для сборки образа приложения FastAPI
├── requirements.txt      # Зависимости Python
├── ruff.toml             # Конфигурация линтера/форматтера Ruff
├── sql/
│   ├── 1_create_tabels.sql # SQL-скрипт для создания таблиц базы данных
│   └── 2_create_data.sql   # SQL-скрипт для заполнения начальных данных
├── src/
│   ├── main.py           # Точка входа в основное приложение FastAPI
│   ├── database/
│   │   └── session.py    # Конфигурация асинхронной сессии SQLAlchemy
│   ├── orders/
│   │   ├── crud.py       # CRUD-операции для позиций заказа
│   │   ├── exceptions.py # Определения исключений для модуля заказов
│   │   ├── routers.py    # API-роуты для заказов
│   │   └── schemas.py    # Pydantic-модели для валидации запросов/ответов
│   └── products/
│       ├── crud.py       # CRUD-операции для товаров
│       └── exceptions.py # Определения исключений для модуля товаров
├── tasks/
│   ├── task-2.1.sql      # SQL-запрос для Задания 2.1
│   ├── task-2.2.sql      # SQL-запрос для Задания 2.2
│   ├── task-2.3.1.sql    # SQL-запрос для Задания 2.3.1 (Топ-5 самых покупаемых товаров)
│   └── task-2.3.2.txt    # Анализ для Задания 2.3.2 (Предложения по оптимизации)
└── tests/
    ├── conftest.py       # Фикстуры pytest (сессия БД, тестовый клиент)
    ├── test_main.py      # Тест приветственного эндпоинта (say_hello)
    └── test_orders_api.py # Тесты API добавления товара в заказ
```

## Конфигурация приложения

Файл `config.py` в корне проекта отвечает за доступ к переменным окружения через **Pydantic Settings**. Он читает переменные из файла, путь к которому указан в переменной `ENV_PATH`:

- `.env` — для основного запуска приложения (Docker Compose)
- `.env_test` — для запуска тестов с тестовой базой данных

## Схема базы данных

Схема базы данных разработана в соответствии с требованиями технического задания, поддерживая `categories` (с неограниченной вложенностью), `products`, `clients`, `orders` и `order_items`.

Схему можно найти в:

```sql
sql/1_create_tabels.sql
```

## API Эндпоинты

Основной API-эндпоинт, реализованный в рамках задания, предназначен для добавления позиций в заказ.

### `POST /orders/create-item`

*   **Описание**: Добавляет указанный товар с заданным количеством в существующий заказ. Если товар уже существует в заказе, его количество обновляется (увеличивается). Цена товара (`price_at_order`) автоматически извлекается из базы данных по `product_id`.
*   **Тело запроса**: `OrderItemCreate` (Pydantic-модель)
    *   `order_id`: `int` - ID заказа, в который будет добавлена позиция.
    *   `product_id`: `int` - ID товара для добавления.
    *   `quantity`: `int` - Количество товара для добавления.
*   **Ответ**: `JSON-объект` (словарь Python)
    *   При успешном выполнении возвращается словарь, содержащий данные созданной/обновленной позиции заказа, например:
        ```json
        {
            "order_item_id": 1,
            "order_id": 1,
            "product_id": 2,
            "quantity": 5,
            "price_at_order": 100.00
        }
        ```
*   **Коды статуса**:
    *   `200 OK`: Если позиция успешно обновлена или добавлена.
    *   `404 Not Found`: Если `order_id` или `product_id` не существуют.
    *   `400 Bad Request`: Если запрашиваемое количество товара превышает доступное.

## Настройка и запуск проекта с Docker Compose

Этот проект использует Docker Compose для упрощения настройки и локальной разработки. Таблицы базы данных и начальные данные будут созданы автоматически при первом запуске Docker Compose.

### Предварительные требования

*   Docker, установленный в вашей системе.

### Шаги

1.  **Клонируйте репозиторий**:

    ```bash
    git clone https://github.com/Arunat-25/tz-alti-guru.git
    cd tz-alti-guru
    ```

2.  **Соберите и запустите с Docker Compose**:
    Эта команда соберет Docker-образы (если не уже собраны), создаст контейнеры для API и базы данных PostgreSQL, запустит их в отсоединенном режиме (в фоне) и **автоматически создаст таблицы и заполнит их данными** из файлов `sql/*.sql` при первом запуске контейнера `marketplace-db`.

    ```bash
    docker compose up -d --build
    ```

    *   `--build` гарантирует, что Docker-образы будут пересобраны, учитывая любые изменения в `Dockerfile` или зависимостях.
    *   `-d` запускает контейнеры в фоновом режиме.

3.  **Доступ к документации API**:
    После запуска контейнера `marketplace-api` вы можете получить доступ к интерактивной документации API (Swagger UI) по адресу:
    `http://localhost:8000/docs`

4.  **Остановка проекта**:
    Чтобы остановить и удалить контейнеры и сети:

    ```bash
    docker compose down
    ```

## SQL-запросы

В рамках задания предоставляются следующие файлы SQL-запросов:

*   `tasks/task-2.1.sql`: Получение информации о сумме товаров, заказанных под каждого клиента (Наименование клиента, сумма).
*   `tasks/task-2.2.sql`: Найти количество дочерних элементов первого уровня вложенности для категорий номенклатуры.
*   `tasks/task-2.3.1.sql`: Текст запроса для отчета «Топ-5 самых покупаемых товаров за последний месяц» (по количеству штук в заказах).
*   `tasks/task-2.3.2.txt`: Анализ запроса 2.3.1 и предложения по оптимизации схемы БД.

## Запуск тестов

Проект включает тесты для проверки API. Тесты используют отдельную тестовую базу данных, чтобы не затрагивать основные данные.

### Шаги для запуска тестов

1.  **Остановите основное приложение** (если оно запущено):

    ```bash
    docker compose down
    ```

2.  **Переключите конфигурацию на тестовое окружение**:
    В файле `config.py` измените путь к файлу переменных окружения:

    ```python
    ENV_PATH = BASE_DIR / ".env_test"  # было: ENV_PATH = BASE_DIR / ".env"
    ```

    > ⚠️ **Важно**: После завершения тестирования не забудьте вернуть значение обратно на `.env` для нормальной работы приложения.

3.  **Запустите тестовую базу данных**:

    ```bash
    docker compose -f compose.test.yml up -d
    ```

4.  **Запустите тесты**:

    ```bash
    PYTHONPATH=. pytest
    ```

5.  **Перезапуск тестовой БД перед повторным запуском тестов**:

    > ⚠️ **Важно**: Тесты изменяют данные в базе данных (добавляют позиции в заказы, уменьшают количество товаров на складе). Из-за этого при **повторном запуске тестов без перезапуска БД не все тесты пройдут**, так как данные уже отличаются от начальных. Перед повторным запуском тестов необходимо пересоздать тестовую БД:

    ```bash
    docker compose -f compose.test.yml down -v
    docker compose -f compose.test.yml up -d
    ```

    После этого можно снова запустить тесты:

    ```bash
    PYTHONPATH=. pytest
    ```
